****************
* Lab04
* CS 321
* 7:53 PM 12/12/2021
* Paul Vanderveen
* Alo Ternois
**************** 

OVERVIEW:

 The project is an application and implementation of BTrees and basic operations on BTrees. 
 The GeneBankCreateBTree and GeneBankSearch programs create BTrees and search them for specific DNA subsequences.

INCLUDED FILES:

 in https://github.com/Hello-Alo/lab4team4

 Java Files:

 src/main/java/cs321/btree/BTree.java
 src/main/java/cs321/btree/BTreeInterface.java
 src/main/java/cs321/btree/TreeObject.java
 src/main/java/cs321/btree/TreeObjectInterface.java
 src/main/java/cs321/common/ParseArgumentException.java
 src/main/java/cs321/common/SequenceUtils.java
 src/main/java/cs321/create/BTreeToFile.java
 src/main/java/cs321/create/GeneBankCreateBTree.java (main program)
 src/main/java/cs321/create/GeneBankCreateBTreeArguments.java
 src/main/java/cs321/search/GeneBankSearchBTree.java (main program)
 src/main/java/cs321/search/GeneBankSearchBTreeArguments.java

BUILDING AND RUNNING:

 clone the following repository:
 https://github.com/Hello-Alo/lab4team4

 $ git clone https://github.com/Hello-Alo/lab4team4

 From the main directory, To run a list of tests for the programs simply run

 $ gradlew.bat

 To compile the source files directly simply run

 $ gradlew assemble

 To run the GeneBankCreateBTree program, enter the command, as follows:
 
 $ java GeneBankCreateBTree <0/1(no/with Cache)> <degree> <gbk file> <sequence length> [<cache size>] [<debug level>]

 To run the GeneBankSearchBTree program, enter the command as follows:

 $ java GeneBankSearch <0/1(no/with Cache)> <btree file> <query file> [<cache size>] [<debug level>]

 -------------------

 The command-line arguments for both of these files are as follows:

 <0 (no cache) | 1 (cache)> specifies whether the program should use cache (value 1) or no cache (value 0); if the value is 1, the <cache_size> has to be specified

 <degree> is the degree to be used for the B-Tree. If the user specifies 0, then your program should choose the optimum degree based on a disk block size of 4096 bytes and the size of your  B-Tree node on disk

 <gbk_file> is the input *.gbk file containing the input DNA sequences

 <subsequence_length> is an integer that must be between 1 and 31 (inclusive)

 < b-tree_file> is the B-Tree file generated by the GeneBankCreateBTree program

 <query file> contains all the DNA strings of a specific subsequence length that we want to search for in the specified B-Tree file. The strings are one per line and they all must have the  same length as the DNA subsequences in the B-Tree file. The DNA strings use A, C, T, and G (either lower or upper case)

 [<cache size>] is an integer between 100 and 500 (inclusive) that represents the maximum number of BTreeNode objects that can be stored in memory

 [<debug level>] is an optional argument with a default value of zero.

 It must support at least the following values for GeneBankSearchBTree:

 0: The output of the queries should be printed on the standard output stream. Any diagnostic messages, help and status messages must be be printed on standard error stream.
It must support at least the following values for GeneBankCreateBTree:

 0: Any diagnostic messages, help and status messages must be be printed on standard error stream.

 1: The program writes a text file named dump, containing the frequency and the DNA string (corresponding to the key stored) in an inorder traversal, and has the following line format:

 -------------------

PROGRAM DESIGN:

 The btree folder in the src folder contains all the necessary programs which implement a BTree, which is the underlying data structure behind the GeneBankCreateBTree and GeneBankSearch programs. The TreeObject class represents a node in a BTree. It has parent and child attributes (pointers to other Tree Objects). It can hold an array of keys of Generic (Comparable) Type. The BTree class implements a BTree using TreeObjects as nodes. It has one attribute for the degree of the BTree. The term 'degree' here means the maximum number of keys that a Node can hold or when a node is full. 
 The create folder in the src folder contains all of the files necessary to create a BTree from a GeneBank File. The BTreeToFile class is the underlying source file for most of the formatting and conversions between GeneBankFiles, BTrees, and BTreeFiles. The BTreeToFile class can take a csv file and convert it into a BTree specified format file. The GeneBankCreateBTree file takes in arguments from the command line (see above), and passes them to the BTreeToFile constructor, which creates a formatted dump file (if specified) and BTreeFile which can later be used to search for specific subsequences in the BTree. The GeneBankCreateBTreeArguments class parses the command line arguments for the GeneBankCreateBTree class and essentially checks that the arguments are valid, or else the file(s) are not created. The command line arguments from GeneBankCreateBTree are passed in via the constructor of this class to check for bad input or errors. 
 The search folder in the src folder contains all of the files necessary to perform searches on the BTree and file generated by the GeneBankCreateBTree program. Command line arguments are passed through GeneBankSearchBTree and are passed in as parameters to the GeneBankSearchBTreeArguments in order to check for errors. Once the argument parsing is completed, the search is executed for the subsequences (of a given length), and a dump file is created with all the search results, and looks something like this:

aaaaaa: 14
aaaaac: 14
aaaaag: 6
aaaaat: 8
aaaaca: 4
...

TESTING:

[Paul]

Testing was done by intergration, so few lines of codes or methods would be written, then tested to make sure that the results are as expected. Among the first of these programs were the TreeObject and BTree class files. Methods were added in to the TreeObject one at a time. I had a sample main program alongside when I was creating the class. I first did basic testing on underlying objects, like the generic nodes that the TreeObject is made up of, whether or not inserting values into the constructor would match the expected output. After verifying the underlying data objects were correctly inserted and constructed and after verifying all of the setters/getters worked correctly, I tested the more advanced methods, such as creating children or setting children nodes from a given TreeObject node, or splitting nodes along a middle or median key. After the TreeObject class was complete, I moved on to the BTree class. 

The BTree Class required exhaustive testing. First, the basics were tested, like getting or setting the root node of the tree, or determining the tree's height. Various test cases were performed on the insert method, such as what is expected when the node is full, the recursive algorithm to split and promote middle or median keys when a node is full. After verifying that these were working as intended, I started implementing and testing the BTreeToFile class.

The BTreeToFile class was relatively easy to test, since the BTree methods were already correct, I just needed to make sure that the file format was acceptable for the purpose of this project. It was not difficult to test a conversion from a csv file to a BTree. After I verified that the BTree was successfully created as expected (from the csv file), I started implementing and testing the conversion from the BTree to the output file. This was more exhaustive than the expected input testing, both to implement and test. Part of the testing included verifying that algorithms used to create the output file (such as a breadth first tree traversal) were correct. 

[Alo]

Most of my testing was done through manual integration testing, except for some difficulty with the
"SequenceUtils" class, which houses the StringToLong and LongToString methods used by both main
classes. When first writing it, I decided that the function would be both difficult to write,
and essential to the accurate function of both programs, I created a small battery of unit tests 
to run the program through as I coded. 

GeneBankSearchTree required a large amount of debugging, which it was not conducive to try to create
unit tests for. In this case, I used the VSCode debugging tools, and printed nodes as I traversed 
them to understand where my search algorithm was going wrong.

GeneBankCreateBTree required little testing, as it is mostly a driver for the BTreeToFile class, 
for which I wrote the I/O handling. 

DISCUSSION:

[Paul]

At first, creating these programs appeared daunting as there were many sources files. We essentially pulled the project from an already partially developed git repo. Part of the issues I was having when creating the underlying files for this project, such as the TreeObject or BTree classes were attempting to implement the methods that were already in the interfaces, but not adding or deleting more. Eventually, I realized that implementing the classes from just the suggested methods in the TreeObject file would be very difficult (or even impossible), and therefore it would be much easier to add in my own methods, which I ended up doing. The same was true for the BTree class. For example, there was no function to get or set the degree of the BTree, which was not in the original repo interface. 
Another problem I had was my perspective on a BTree to what is expected. Part of the terminoligy of the BTree was confusing, such as the degree and order of the BTree. (In the lectures), for example, the degree is taken to be the minimum number of children for each node, and the order is the maximum number of children per node. The order can be an aribtrary number, but using these definition, it is restricted to even numbers.
My approach to this was to only use one specifier, which I called degree. My interpretation of degree was instead to count the maximum number of keys a node can hold (one less than the "order"), or when a node is full. I could afford to only focus on one specification because doing so would not violate the BTree property (for example, it was unecessary to check the minimum number of children, or that a node has exactly n+1 children).
Some other issues I ran into when programming were the file formats. My teammate and I were trying to come up with a file format for the GeneBankBTree Create and Search files that we could both understand and agree on. While we eventually agreed on a file format, implementing it was more difficult than expected. Normally, it would be easy to read and write a BTree or list of (sorted) data to output. However, given the structure of the BTree, I had to realize that the agreed upon file format was really just a breadth first traversal of the BTree. This meant that it would require more logic involved, because my file output formatting method has to implement a Breadth first search algorithm. 

[Alo]

My main issue during programming was the use of the file format we agreed on. The way I ended up 
searching the file, I feel is rather clever. A line is read from the file, then turned into 
a TreeObject, which is discarded soon after, keeping memory usage very low. 
I had some minor troubles figuring out what "degree" meant in the context of Paul's code, but soon 
came to the realization that I could do everything I needed to do without needing to reference the 
degree of the TreeObject, thus side-stepping the issue.
Quite honestly, making the StringToLong and LongToString methods were the most difficult parts of
the project for me, as translating data between two forms in this way was an entirely new problem
for me. It ended up requiring much more formatting and manipulation than I had initially anticipated.

EXTRA CREDIT: 

BTree and TreeObject both implement generics.